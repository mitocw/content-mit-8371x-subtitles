#
# File:   content-mit-8371x-subtitles/Q1L5f.txt
#
# Captions for 8.421x module
#
# This file has 139 caption lines.
#
# Do not add or delete any lines.  If there is text missing at the end, please add it to the last line.
#
#----------------------------------------

Stabilizer codes capture the properties of subspaces.
In a similar way, might we be able to generalize graph states
to become graph codes, which encode multi-dimensional qubit
spaces?
The answer is yes.
And this can be done in the following way, based
on the fact that there's a degeneracy.
A stabilizer state, with generator gk,
changes to a different stabilizer
when the sign is flipped.
The graph is the same, but the state is different.
Thus we may define a concept known as a graph basis.
For a given graph state G, the graph basis
is a set of all stabilizer states given by Z to the string
S acting on the graph state G. Again, G is a graph state.
And this is a state of n qubits.
And Z to the S causes the signs on the generators of g
to change.
We can see how this happens by recalling
that the unitary operation on the stabilizer state
can be represented in the Heisenberg picture
by conjugating g instead of just thinking
about its action on the state.
This transformation of the stabilizer by conjugation
reveals that, for a graph state with generators g1, g2,
through gn, we find the graph basis
state Gs to be generated by minus 1 to the S1,
the first bit of S, times G1, minus 1 to the S2,
the second bit of S, all the way up through the Nth bit of S.
These bits of S change the signs,
or indicate the appropriate signs of the generators to use.
So therefore, G sub s for all possible bitstrings
S is a complete orthonormal basis for the n qubit Hilbert
space of the system.
Of course, in general, we will not
be interested in all possible S. We
will be interested in a subset.
But the basic idea behind this is the fact
that different stabilizers lead to orthogonal states.
And with 2 to the n different strings S,
we have a complete set of states for the Hilbert space.
Given the graph basis as a mechanism
for parametrizing vector spaces,
we may now employ graphs to define codes.
We define a graph code specified
by a graph G and a set of strings, S1, S2, and so
forth, all n bit strings, as being
the vector space spanned by the graph basis states G sub S.
That is, G sub S1, G sub S2, and so forth up to the number
of strings being used.
Again, G here is a graph state, a stabilizer specified graph
state.
And S1, S2, and so forth are n bit binary strings.
These strings indicate the signs.
And each of these states has its own stabilizer.
They have the same operators in the form of a graph,
but with different signs.
Graph codes make it possible to correct number of errors.
And it is useful to parameterize that number.
We capture this idea by saying that a stabilizer
code of distance d has the property
that, for all Pauli errors,
that is, errors in Gn, of weight less than d, meaning the number
of non-identity elements is less than d,
either E will be in the stabilizer
or E will anti commute with some stabilizer element G.
It is convenient to re-express d as being 2t plus 1,
where t is the number of errors which
can be corrected by the code.
Let us now look at some examples of graph codes.
As a first example, consider this trivial case
with 3 qubits having the graph state stabilizer X I I,
I X I, and I I X. Here the 3 qubits are
trivial because they are not connected to each other
by any edges.
Let's see if we can determine the distance of this code.
The graph state itself is the plus plus plus state.
And suppose we take, as the strings, 0 0 0 and 1 1 1,
such that the graph basis states for the code are
G and Z cubed acting on G, which gives minus minus minus.
The stabilizers for this code are generated by X X I and I X
X, for example.
And thus, we can see, by observation,
that the error X1, X acting on the first qubit,
is not in S but also commutes with all of the stabilizers
and thus the distance of this code is 1.
As a second example, consider the graph state
given by 2 qubits which are connected by an edge.
This graph can be turned into a graph code using
as basis states G and Z Z acting on G.
The stabilizer for this code space is, for example, Y Y.
And therefore, by observation, we
note that minus I Y is not in the stabilizer but commutes
with all of the stabilizer generators.
And thus, the distance is 1.
OK, how about a more nontrivial example?
Let us look at a graph state given
by a pentagon of qubits connected simply,
as shown here, with, again, 5 qubits-- 1, 2, 3, 4, and 5.
This graph state has the stabilizer X Z I I Z
and cyclic permutations of this.
There are five generators because there are 5 qubits.
And again, the stabilizer generates a state, not a space.
These five generators, G1 through G5-- again,
they are cyclic-- may be used to generate code words for a graph
code, first by taking G itself as a code word state, and then
Z to the 5.
5 Z operators acting on G as a second code word state.
Think of these as logical 0 and logical 1.
The stabilizer for this code word space
is generated by X I X Z Z and cyclic permutations.
These are constructed from the graph state generators
by taking products such that Z to the 5 commutes with them.
Note that there are four generators because the coding
codes a qubit.
These generators are the same as those for the 5, 1 code.
And the code has distance 3, as you can
see for yourself by inspection.
We often write this code, therefore, as a 5 1 3 quantum
error correction code, n k d.
As a fourth, final example, consider the graph state
defined by this graph.
We may always start with a graph. Every graph has a graph
state associated with it.
Again the vertices are qubits, and we
have vertices at these three intersection points,
as well as at the ends of each one of these lines.
There are nine nodes, and we number them as 1,
2, 3, for the middle, 4, 5, 6, 7, 8, 9 for the outer qubits.
This, in fact, turns out to be the Shor 9-qubit code.
And the graph state and Z 1, Z 2,
Z 3 acting on the graph state form our logical 0
and logical 1 qubits.
This is a fascinating way to see what the 9-qubit code does.
In fact, you can see, by this diagram,
the concatenated structure of the 9-qubit code-- 3 qubits
for bit flip, 3 qubits for phase flip encoding.
See if you can work out for yourself the distance and other properties of this code.